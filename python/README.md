# Pizza Factory Coding Challenge üçï

## Overview
This is a coding challenge designed for technical interviews, similar to the burger robot problem but with increased complexity and real-world applicability.

## Challenge Description
You're working at a pizza factory that needs to optimize pizza production. The factory receives orders and must determine how many pizzas can be made with available ingredients.

## Files Created
- `pizza_factory.py` - The challenge template with requirements
- `pizza_factory_solution.py` - Sample solution implementation
- `README.md` - This file with additional interview guidance

## Interview Questions & Discussion Points

### Technical Questions
1. **Algorithm Complexity**: What's the time complexity of your solution? Can you optimize it?
2. **Data Structures**: Why did you choose dictionaries for recipes? What are the alternatives?
3. **Edge Cases**: How would you handle invalid pizza types? Empty ingredient lists?
4. **Scalability**: How would you modify this for 1000+ different pizza types?

### Design Questions
5. **Architecture**: How would you structure this code for a real pizza factory system?
6. **Extensibility**: How easy is it to add new pizza types or modify existing recipes?
7. **Error Handling**: What error conditions should be handled gracefully?

### Problem-Solving Questions
8. **Optimization**: The bonus challenge asks for optimal pizza making - how would you approach this?
9. **Constraints**: What if ingredients have expiration dates or costs?
10. **Real-world**: How would you modify this for a delivery system with customer preferences?

## Evaluation Criteria

### Junior Developer (0-2 years)
- ‚úÖ Basic function implementation
- ‚úÖ Simple test cases
- ‚úÖ Clear variable names
- ‚úÖ Basic error handling

### Mid-Level Developer (2-5 years)
- ‚úÖ Clean, readable code structure
- ‚úÖ Comprehensive test coverage
- ‚úÖ Proper error handling and validation
- ‚úÖ Good use of data structures
- ‚úÖ Documentation and comments

### Senior Developer (5+ years)
- ‚úÖ All above requirements
- ‚úÖ Optimal algorithm implementation
- ‚úÖ Extensible design patterns
- ‚úÖ Performance considerations
- ‚úÖ Edge case handling
- ‚úÖ Code organization and modularity

## Bonus Challenges

### 1. Ingredient Priority System
Implement a system where expensive ingredients are used last, or ingredients with shorter shelf life are prioritized.

### 2. Custom Pizza Builder
Allow users to create custom pizza recipes with their own ingredient requirements.

### 3. Batch Processing
Handle multiple orders simultaneously and optimize ingredient allocation across orders.

### 4. Cost Optimization
Add ingredient costs and optimize for the most profitable pizza combinations.

### 5. Inventory Management
Implement a system that tracks ingredient inventory and suggests when to reorder.

## Sample Interview Flow

### Phase 1: Problem Understanding (5 minutes)
- Read the requirements together
- Ask clarifying questions
- Discuss approach before coding

### Phase 2: Implementation (20-30 minutes)
- Start with basic functionality
- Add error handling
- Write test cases

### Phase 3: Discussion (10-15 minutes)
- Code review and optimization
- Discuss edge cases
- Explore extensions

### Phase 4: Bonus Challenges (10-20 minutes)
- Implement bonus features
- Discuss scalability
- Real-world applications

## Tips for Candidates

### Before Starting
- Ask clarifying questions about requirements
- Think about edge cases upfront
- Plan your approach before coding

### During Implementation
- Start simple, then add complexity
- Write tests as you go
- Use clear, descriptive variable names
- Handle errors gracefully

### During Discussion
- Explain your thought process
- Discuss trade-offs in your approach
- Be open to feedback and improvements
- Think about real-world applications

## Common Pitfalls to Avoid

1. **Not handling edge cases** (empty lists, invalid pizza types)
2. **Hardcoding values** instead of using data structures
3. **Poor variable naming** (single letters, unclear names)
4. **Missing error handling** for invalid inputs
5. **Not testing thoroughly** with various scenarios
6. **Overcomplicating** the initial solution

## Success Metrics

- ‚úÖ All test cases pass
- ‚úÖ Code is readable and well-structured
- ‚úÖ Handles edge cases gracefully
- ‚úÖ Good use of Python idioms
- ‚úÖ Clear documentation
- ‚úÖ Extensible design

Good luck! üöÄ
